<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Video Stream Sender</title>
</head>
<body>

<video id="video-stream-source" controls autoplay></video>
<script src="https://cdn.jsdelivr.net/npm/base64-js@1.5.1/base64js.min.js"></script>
<script src="signalr.js"></script>
<script>
    const peerConnections = {};
    const config = {
        iceServers: [
            {url:'stun:stun4.l.google.com:19302'}
        ]
    };

    // Создаем соединение с сервером SignalR
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("https://localhost:7143/hubs/broadcaster") // Указываем путь к Hub
        .configureLogging(signalR.LogLevel.Information)
        .build();

    const videoElement = document.getElementById("video-stream-source"); // Получаем элемент видео

    connection.on("answer", (id, description) => {
        console.log("Received answer: ", id, description);
        if (peerConnections[id]) {
            peerConnections[id].setRemoteDescription(new RTCSessionDescription(description))
                .then(() => console.log(`Remote description set for ID: ${id}`))
                .catch(err => console.error(`Error setting remote description for ID: ${id}`, err));
        }
        else {
            console.error(`No PeerConnection found for ID: ${id}`);
        }
    });

    connection.on("watcher", id => {
        const peerConnection = new RTCPeerConnection(config);
        peerConnections[id] = peerConnection;
        console.log("Peer Connection", peerConnection)
        
        let stream = videoElement.srcObject;
        if (stream) {
            stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
        } else {
            console.error("Video stream is not available.");
            return;
        }

        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                console.log("CandidateId == ", id, event.candidate)
                const candidate = JSON.stringify(event.candidate);
                return connection.invoke("SendCandidate", id, candidate);
            }
        };

        peerConnection.createOffer()
            .then(offer => {
                console.log("Original SDP:", offer.sdp);
                const modifiedOffer = setPreferedCodec(offer.sdp, 'VP9'); // или другой кодек
                console.log("Modified SDP:", modifiedOffer);
                return peerConnection.setLocalDescription(new RTCSessionDescription({
                    type: offer.type,
                    sdp: offer.sdp
                }));
            })
            .then(() => {
                if (!peerConnection.localDescription || !peerConnection.localDescription.sdp) {
                    console.error("Invalid localDescription, cannot send offer");
                    return;
                }
                console.log("Sending Offer with ID:", id);
                // Теперь, когда локальное описание установлено, оно не будет null
                //console.log("Local Description set:", peerConnection.localDescription);
                if (!id || !peerConnection.localDescription) {
                    console.error("Invalid parameters for SendOffer: ", { id, localDescription: peerConnection.localDescription });
                    return;
                }
                const localDescruptionJson = JSON.stringify(peerConnection.localDescription);
                connection.invoke("SendOffer", id, localDescruptionJson)
            })
            .catch(error => {
                console.error("Error creating offer or setting local description:", error);
            });
    });

    connection.on("candidate", (id, candidate) => {
        peerConnections[id].addIceCandidate(new RTCIceCandidate(candidate));
    });

    connection.on("disconnectPeer", id => {
        peerConnections[id].close();
        delete peerConnections[id];
    });

    window.onunload = window.onbeforeunload = () => {
        connection.stop();
    };

    // Получение потока с экрана

    getDisplayMedia()
        .then(stream => {
            if (!stream) {
                console.error("No stream available.");
                return; // Если поток отсутствует, выходим
            }
            videoElement.srcObject = stream; // Назначаем поток на элемент видео
            console.log("Media stream assigned:", stream); // Логируем назначенный поток

            const peerConnection = new RTCPeerConnection(config); // Инициализируем соединение
            stream.getTracks().forEach(track => {
                peerConnection.addTrack(track, stream); // Добавляем треки к peerConnection
            });

            // Уведомляем о начале передачи потока
            connection.invoke("RegisterBroadcaster");
        })
        .catch(handleError);

    // Функция для получения потока с экрана
    function getDisplayMedia() {
        return navigator.mediaDevices.getDisplayMedia({ video: true }); // Запрашиваем поток с экрана
    }

    function setPreferedCodec(sdp, codec) {
        sdp = sdp.replace(/a=rtpmap:\d+ H264\/90000\r\n/g, '');
        sdp = sdp.replace(/a=fmtp:\d+ .*H264.*?\r\n/g, '');

        // Можно добавить аналогичные строки для других кодеков...

        // Если добавляется H264
        const newH264Id = 120; // Новый уникальный идентификатор, который не используется
        sdp += `a=rtpmap:${newH264Id} H264/90000\r\n`;
        sdp += `a=fmtp:${newH264Id} profile-level-id=42001f;packetization-mode=1\r\n`;

        return sdp;
    }
    
    function handleError(error) {
        console.error("Error: ", error);
    }

    // Запуск соединения с сервером
    connection.start()
        .then(() => console.log('Connection started'))
        .catch(err => console.error('Error while starting connection: ', err));
</script>
</body>
</html>