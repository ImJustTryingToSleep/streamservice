<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Video Stream Sender</title>
</head>
<body>

<video id="video-stream-source" controls autoplay></video>
<script src="https://cdn.jsdelivr.net/npm/base64-js@1.5.1/base64js.min.js"></script>
<script src="signalr.js"></script>
<script>
    // Хранит экземпляры RTCPeerConnection
    const peerConnections = {};
    // Конфигурация для RTCPeerConnection. Указывает сервер Google STUN для обхода NAT.
    const config = {
        iceServers: [
            {url:'stun:stun4.l.google.com:19302'}
        ]
    };

    // Создаем соединение с сервером SignalR
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("https://localhost:7143/hubs/broadcaster")
        .configureLogging(signalR.LogLevel.Information)
        .build();
    
    // Получаем элемент видео
    const videoElement = document.getElementById("video-stream-source"); 
    
    //Обработка ответа от зрителя
    //Когда зритель отправляет ответ SDP, стример получает его.
    connection.on("answer", (id, description) => {
        console.log("Received answer: ", id, description);
        if (peerConnections[id]) {
            //Устанавливаем удаленное описание на соответствующем RTCPeerConnection.
            peerConnections[id].setRemoteDescription(new RTCSessionDescription(description))
                .then(() => console.log(`Remote description set for ID: ${id}`))
                .catch(err => console.error(`Error setting remote description for ID: ${id}`, err));
        }
        else {
            console.error(`No PeerConnection found for Id: ${id}`);
        }
    });

    //Обработка нового зрителя
    connection.on("watcher", id => {
        //Создаем новый RTCPeerConnection для этого зрителя.
        const peerConnection = new RTCPeerConnection(config);
        peerConnections[id] = peerConnection;
        console.log("Peer Connection", peerConnection)
        
        let stream = videoElement.srcObject;
        
        //Добавляем захваченные медиатреки в это соединение.
        if (stream) {
            stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));
        } else {
            console.error("Video stream is not available.");
            return;
        }
        
        //Обрабатываем ICE кандидатов, отправляя их в хаб
        peerConnection.onicecandidate = event => {
            if (event.candidate) {
                console.log("CandidateId == ", id, event.candidate)
                const candidate = JSON.stringify(event.candidate);
                return connection.invoke("SendCandidate", id, candidate);
            }
        };
        
        //Создаем предложение SDP и отправляем его зрителю
        peerConnection.createOffer()
            .then(offer => {
                return peerConnection.setLocalDescription(new RTCSessionDescription({
                    type: offer.type,
                    sdp: offer.sdp
                }));
            })
            .then(() => {
                if (!peerConnection.localDescription || !peerConnection.localDescription.sdp) {
                    console.error("Invalid localDescription, cannot send offer");
                    return;
                }
                console.log("Sending Offer with ID:", id);
                
                if (!id || !peerConnection.localDescription) {
                    console.error("Invalid parameters for SendOffer: ", { id, localDescription: peerConnection.localDescription });
                    return;
                }
                
                const localDescruptionJson = JSON.stringify(peerConnection.localDescription);
                connection.invoke("SendOffer", id, localDescruptionJson)
            })
            .catch(error => {
                console.error("Error creating offer or setting local description:", error);
            });
    });

    //Обработка ICE кандидатов  от зрителя
    connection.on("candidate", (id, candidate) => {
        // ICE кандидаты от зрителя принимаются и добавляются в соответствующий RTCPeerConnection.
        peerConnections[id].addIceCandidate(new RTCIceCandidate(candidate));
    });

    //Обработка отключений зрителей
    connection.on("disconnectPeer", id => {
        //Если зритель отключается, связанный RTCPeerConnection закрывается и удаляется из peerConnections.
        console.log("Watcher disconnected:", id);
        peerConnections[id].close();
        delete peerConnections[id];
    });

    window.onunload = window.onbeforeunload = () => {
        connection.stop();
    };

    // Получение потока с экрана
    navigator.mediaDevices.getDisplayMedia({video: true})
        .then(function (stream) {
            if (!stream) {
                console.error("No stream available.");
                return; // Если поток отсутствует, выходим
            }
            
            videoElement.srcObject = stream; // Назначаем поток на элемент видео
            console.log("Media stream assigned:", stream);

            const peerConnection = new RTCPeerConnection(config); // Инициализируем соединение
            stream.getTracks().forEach(track => {
                peerConnection.addTrack(track, stream); // Добавляем треки к peerConnection
            });

            // Уведомляем о начале передачи потока
            connection.invoke("RegisterBroadcaster");
        })
        .catch(err => console.error("Error: ", err));

    // Запуск соединения с сервером
    connection.start()
        .then(() => console.log('Connection started'))
        .catch(err => console.error('Error while starting connection: ', err));
</script>
</body>
</html>